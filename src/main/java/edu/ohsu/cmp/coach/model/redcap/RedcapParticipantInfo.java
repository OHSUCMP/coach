package edu.ohsu.cmp.coach.model.redcap;

import edu.ohsu.cmp.coach.model.RedcapDataAccessGroup;
import edu.ohsu.cmp.coach.service.REDCapService;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Map;

/**
 * An entity that represents the participant's current state in REDCap
 */
public class RedcapParticipantInfo {
    
    private static final Logger logger = LoggerFactory.getLogger(RedcapParticipantInfo.class);

    private String recordId; // The autogenerated id in REDCap
    private String coachId; // The uuid generated by COACH and stored in both places
    private boolean exists;
    private boolean isInformationSheetComplete;
    private boolean hasConsentRecord;
    private boolean isConsentGranted;
    private boolean isRandomized;
    private RandomizationGroup randomizationGroup;
    private Date randomizationDate;
    private boolean isWithdrawn;
    private Boolean completedPerProtocol;
    private Date protocolCompletionDate;

    /**
     * Return an object representing a participant that doesn't exist in REDCap yet.
     * @param coachId
     * @return
     */
    public static RedcapParticipantInfo buildNotExists(String coachId) {
        RedcapParticipantInfo pi = new RedcapParticipantInfo();
        pi.setRecordId(coachId); // This will be replaced when the participant is created in REDCap, but needs to be passed anyway
        pi.setCoachId(coachId);
        pi.setExists(false);
        return pi;
    }

    /**
     * Build the relevant REDCap participant information using data from the baseline event and ongoing
     * event if it exists.
     * @param coachId
     * @param baseline
     * @param ongoing
     * @return
     */
    public static RedcapParticipantInfo buildFromRecord(String coachId, RedcapDataAccessGroup dag, Map<String, String> baseline, Map<String,String> ongoing) {
        RedcapParticipantInfo pi = new RedcapParticipantInfo();
        pi.setRecordId(baseline.get(REDCapService.PARTICIPANT_RECORD_ID_FIELD));
        pi.setCoachId(coachId);
        pi.setExists(true);
        pi.setIsInformationSheetComplete(StringUtils.equals(baseline.get(REDCapService.PARTICIPANT_INFORMATION_SHEET_FORM + "_complete"), REDCapService.FORM_COMPLETE));
        pi.setHasConsentRecord(StringUtils.equals(baseline.get(REDCapService.PARTICIPANT_CONSENT_FORM + "_complete"), REDCapService.FORM_COMPLETE));
        if (dag.equals(RedcapDataAccessGroup.VUMC)) {
            pi.setIsConsentGranted(pi.getHasConsentRecord() && 
                StringUtils.equals(baseline.get(REDCapService.PARTICIPANT_CONSENT_FIELD), REDCapService.YES) &&
                StringUtils.equals(baseline.get(REDCapService.PARTICIPANT_VUMC_ADDITIONAL_CONSENT), REDCapService.YES)
            );

        } else {
            pi.setIsConsentGranted(pi.getHasConsentRecord() && 
                StringUtils.equals(baseline.get(REDCapService.PARTICIPANT_CONSENT_FIELD), REDCapService.YES)
            );
        }
        // Check that the randomization and randomization date fields have been filled out
        String randString = baseline.get(REDCapService.PARTICIPANT_RANDOMIZATION_FIELD);
        String randDateString = baseline.get(REDCapService.PARTICIPANT_RANDOMIZATION_DATE_FIELD);
        pi.setIsRandomized(StringUtils.isNotBlank(randString) && StringUtils.isNotBlank(randDateString));

        String completedPerProtocolString = ongoing.get(REDCapService.PARTICIPANT_COMPLETED_PER_PROTOCOL_FIELD);
        String protocolCompletionDateString = ongoing.get(REDCapService.PARTICIPANT_PROTOCOL_COMPLETION_DATE_FIELD);

        if (pi.getIsRandomized()) {
            try {
                int rand = Integer.parseInt(randString);
                pi.setRandomizationGroup(RandomizationGroup.getByRedcapCode(rand));
            } catch (IllegalArgumentException e) {
                pi.setRandomizationGroup(RandomizationGroup.ENHANCED);
                RedcapParticipantInfo.logger.error("Randomization Group " + randString + " is not understood. User " + coachId + " will get ENHANCED experience.");
            }

            try {
                SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
                pi.setRandomizationDate(sdf.parse(randDateString));
            } catch (ParseException e) {
                pi.setIsRandomized(false);
                pi.setRandomizationGroup(null);
                RedcapParticipantInfo.logger.error("Randomization date " + randDateString + " is not understood. User " + coachId + " is denied access.");
            }

            Boolean completedPerProtocol = null;
            if (StringUtils.isNotBlank(completedPerProtocolString)) {
                if      (StringUtils.equals(completedPerProtocolString, REDCapService.YES)) completedPerProtocol = true;
                else if (StringUtils.equals(completedPerProtocolString, REDCapService.NO))  completedPerProtocol = false;
                else {
                    RedcapParticipantInfo.logger.error("Completed-per-protocol value '" + completedPerProtocolString + "' is not understood.  User " + coachId + " will be considered actively enrolled.");
                }
            }
            pi.setCompletedPerProtocol(completedPerProtocol);

            if (completedPerProtocol != null) {
                try {
                    // completion date should always be set if completedPerProtocol != null
                    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
                    pi.setProtocolCompletionDate(sdf.parse(protocolCompletionDateString));

                } catch (ParseException e) {
                    RedcapParticipantInfo.logger.error("Protocol Completion Date '" + protocolCompletionDateString + "' could not be parsed.  User " + coachId + " will be considered actively enrolled.");
                    pi.setCompletedPerProtocol(null);
                }
            }
        }
        pi.setIsWithdrawn(StringUtils.equals(ongoing.get(REDCapService.PARTICIPANT_DISPOSITION_WITHDRAW_FIELD), REDCapService.YES));
        return pi;
    }

    public String getRecordId() {
        return recordId;
    }

    public void setRecordId(String recordId) {
        this.recordId = recordId;
    }

    public String getCoachId() {
        return this.coachId;
    }

    public void setCoachId(String coachId) {
        this.coachId = coachId;
    }

    /**
     * Return whether the record exists in REDCap
     * @return
     */
    public boolean getExists() {
        return exists;
    }

    public void setExists(boolean exists) {
        this.exists = exists;
    }

    /**
     * Return whether the participant information sheet is marked complete
     * @return
     */
    public boolean getIsInformationSheetComplete() {
        return isInformationSheetComplete;
    }

    public void setIsInformationSheetComplete(boolean isInformationSheetComplete) {
        this.isInformationSheetComplete = isInformationSheetComplete;
    }

    /**
     * Return whether the participant has a completed consent record
     * @return
     */
    public boolean getHasConsentRecord() {
        return hasConsentRecord;
    }

    public void setHasConsentRecord(boolean hasConsentRecord) {
        this.hasConsentRecord = hasConsentRecord;
    }

    /**
     * Return whether the participant has a completed consent record that is 'Yes'
     * @return
     */
    public boolean getIsConsentGranted() {
        return isConsentGranted;
    }

    public void setIsConsentGranted(boolean isConsentGranted) {
        this.isConsentGranted = isConsentGranted;
    }

    /**
     * Return whether the participant has a completed randomization form
     * @return
     */
    public boolean getIsRandomized() {
        return isRandomized;
    }

    public void setIsRandomized(boolean isRandomized) {
        this.isRandomized = isRandomized;
    }

    /**
     * Return the participant's randomization
     * @return
     */
    public RandomizationGroup getRandomizationGroup() {
        return randomizationGroup;
    }

    public void setRandomizationGroup(RandomizationGroup randomizationGroup) {
        this.randomizationGroup = randomizationGroup;
    }

    /**
     * Returns the randomization date for the participant or null if they are not randomized
     * @return
     */
    public Date getRandomizationDate() {
        return randomizationDate;
    }

    public void setRandomizationDate(Date randomizationDate) {
        this.randomizationDate = randomizationDate;
    }

    /**
     * Return whether the participant is withdrawn from the study
     * @return
     */
    public boolean getIsWithdrawn() {
        return isWithdrawn;
    }

    public void setIsWithdrawn(boolean isWithdrawn) {
        this.isWithdrawn = isWithdrawn;
    }

    /**
     * Return whether the participant is actively enrolled by looking as consent, randomization, and disposition
     * @return
     */
    public boolean getIsActivelyEnrolled() {
        return getExists() && getIsConsentGranted() && getIsRandomized() && !getIsWithdrawn() && !isHasCompletedStudy();
    }

    /**
     * @return null if the participant has not completed the study, true if the participant has completed the study
     *         according to the protocol, or false if the participant has completed the study but did not adhere
     *         to the protocol.
     */
    public Boolean isCompletedPerProtocol() {
        return completedPerProtocol;
    }

    public void setCompletedPerProtocol(Boolean completedPerProtocol) {
        this.completedPerProtocol = completedPerProtocol;
    }

    public Date getProtocolCompletionDate() {
        return protocolCompletionDate;
    }

    public void setProtocolCompletionDate(Date protocolCompletionDate) {
        this.protocolCompletionDate = protocolCompletionDate;
    }

    public boolean isHasCompletedStudy() {
        return isCompletedPerProtocol() != null &&
                getProtocolCompletionDate() != null && getProtocolCompletionDate().before(new Date());
    }
    
}

